"""
Tests d'intégration avec unittest.

Ce module contient les tests features utilisant le framework unittest
comme requis dans les spécifications du projet.
"""

import unittest
import sys
from pathlib import Path

# Ajouter le répertoire src au path pour les imports
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

import pandas as pd
from banking_api.data_manager import data_manager
from banking_api.services.transactions_service import TransactionsService
from banking_api.services.stats_service import StatsService
from banking_api.services.fraud_detection_service import FraudDetectionService
from banking_api.models import TransactionSearchRequest, FraudPredictionRequest


class TestIntegrationTransactions(unittest.TestCase):
    """Tests d'intégration pour les transactions."""

    @classmethod
    def setUpClass(cls) -> None:
        """
        Configure les données de test pour toute la classe.
        """
        data = {
            "id": ["tx_0001", "tx_0002", "tx_0003", "tx_0004", "tx_0005"],
            "step": [1, 1, 2, 2, 3],
            "type": ["PAYMENT", "TRANSFER", "CASH_OUT", "DEBIT", "CASH_IN"],
            "amount": [9839.64, 181.0, 181.0, 52091.28, 1000.0],
            "nameOrig": ["C1231006815", "C1666544295", "C1305486145", "C840083671", "C1234567890"],
            "oldbalanceOrg": [170136.0, 181.0, 0.0, 56000.0, 5000.0],
            "newbalanceOrig": [160296.36, 0.0, 0.0, 3908.72, 6000.0],
            "nameDest": ["M1979787155", "C1900366749", "C840083671", "C38997010", "M1234567890"],
            "oldbalanceDest": [0.0, 0.0, 41554.0, 50585.53, 0.0],
            "newbalanceDest": [0.0, 21182.0, 0.0, 102676.81, 0.0],
            "isFraud": [0, 1, 1, 0, 0],
            "isFlaggedFraud": [0, 0, 0, 0, 0],
        }
        df = pd.DataFrame(data)
        data_manager._data = df
        data_manager._loaded = True

    def test_transaction_workflow(self) -> None:
        """
        Teste le flux complet de gestion des transactions.
        """
        # Récupérer toutes les transactions
        result = TransactionsService.get_transactions(page=1, limit=10)
        self.assertEqual(result.total, 5)
        self.assertEqual(len(result.transactions), 5)

        # Récupérer une transaction spécifique
        transaction = TransactionsService.get_transaction_by_id("tx_0001")
        self.assertIsNotNone(transaction)
        self.assertEqual(transaction.type, "PAYMENT")

        # Rechercher des transactions
        search_request = TransactionSearchRequest(type="TRANSFER", isFraud=1)
        search_result = TransactionsService.search_transactions(search_request)
        self.assertEqual(search_result.total, 1)

    def test_transaction_filtering(self) -> None:
        """
        Teste les différents filtres de transactions.
        """
        # Filtre par type
        result = TransactionsService.get_transactions(transaction_type="PAYMENT")
        self.assertEqual(result.total, 1)

        # Filtre par fraude
        result = TransactionsService.get_transactions(is_fraud=1)
        self.assertEqual(result.total, 2)

        # Filtre par montant
        result = TransactionsService.get_transactions(min_amount=1000, max_amount=10000)
        self.assertEqual(result.total, 2)

    def test_transaction_pagination(self) -> None:
        """
        Teste la pagination des transactions.
        """
        # Page 1 avec 2 éléments
        result = TransactionsService.get_transactions(page=1, limit=2)
        self.assertEqual(result.page, 1)
        self.assertEqual(result.limit, 2)
        self.assertEqual(len(result.transactions), 2)

        # Page 2 avec 2 éléments
        result = TransactionsService.get_transactions(page=2, limit=2)
        self.assertEqual(len(result.transactions), 2)


class TestIntegrationStats(unittest.TestCase):
    """Tests d'intégration pour les statistiques."""

    @classmethod
    def setUpClass(cls) -> None:
        """
        Configure les données de test pour toute la classe.
        """
        data = {
            "id": ["tx_0001", "tx_0002", "tx_0003", "tx_0004", "tx_0005"],
            "step": [1, 1, 2, 2, 3],
            "type": ["PAYMENT", "TRANSFER", "CASH_OUT", "DEBIT", "CASH_IN"],
            "amount": [9839.64, 181.0, 181.0, 52091.28, 1000.0],
            "nameOrig": ["C1231006815", "C1666544295", "C1305486145", "C840083671", "C1234567890"],
            "oldbalanceOrg": [170136.0, 181.0, 0.0, 56000.0, 5000.0],
            "newbalanceOrig": [160296.36, 0.0, 0.0, 3908.72, 6000.0],
            "nameDest": ["M1979787155", "C1900366749", "C840083671", "C38997010", "M1234567890"],
            "oldbalanceDest": [0.0, 0.0, 41554.0, 50585.53, 0.0],
            "newbalanceDest": [0.0, 21182.0, 0.0, 102676.81, 0.0],
            "isFraud": [0, 1, 1, 0, 0],
            "isFlaggedFraud": [0, 0, 0, 0, 0],
        }
        df = pd.DataFrame(data)
        data_manager._data = df
        data_manager._loaded = True

    def test_statistics_overview(self) -> None:
        """
        Teste les statistiques globales.
        """
        overview = StatsService.get_overview()
        self.assertEqual(overview.total_transactions, 5)
        self.assertEqual(overview.fraud_rate, 0.4)
        self.assertGreater(overview.avg_amount, 0)

    def test_statistics_by_type(self) -> None:
        """
        Teste les statistiques par type.
        """
        stats = StatsService.get_stats_by_type()
        self.assertEqual(len(stats), 5)

        # Vérifier que tous les types sont présents
        types = [stat.type for stat in stats]
        self.assertIn("PAYMENT", types)
        self.assertIn("TRANSFER", types)

    def test_amount_distribution(self) -> None:
        """
        Teste la distribution des montants.
        """
        distribution = StatsService.get_amount_distribution(bins_count=5)
        self.assertEqual(len(distribution.bins), 5)
        self.assertEqual(len(distribution.counts), 5)
        self.assertEqual(sum(distribution.counts), 5)

    def test_daily_statistics(self) -> None:
        """
        Teste les statistiques quotidiennes.
        """
        daily_stats = StatsService.get_daily_stats()
        self.assertGreater(len(daily_stats), 0)

        # Vérifier que les statistiques sont triées par step
        steps = [stat.step for stat in daily_stats]
        self.assertEqual(steps, sorted(steps))


class TestIntegrationFraudDetection(unittest.TestCase):
    """Tests d'intégration pour la détection de fraude."""

    @classmethod
    def setUpClass(cls) -> None:
        """
        Configure les données de test pour toute la classe.
        """
        data = {
            "id": ["tx_0001", "tx_0002", "tx_0003", "tx_0004", "tx_0005"],
            "step": [1, 1, 2, 2, 3],
            "type": ["PAYMENT", "TRANSFER", "CASH_OUT", "DEBIT", "CASH_IN"],
            "amount": [9839.64, 181.0, 181.0, 52091.28, 1000.0],
            "nameOrig": ["C1231006815", "C1666544295", "C1305486145", "C840083671", "C1234567890"],
            "oldbalanceOrg": [170136.0, 181.0, 0.0, 56000.0, 5000.0],
            "newbalanceOrig": [160296.36, 0.0, 0.0, 3908.72, 6000.0],
            "nameDest": ["M1979787155", "C1900366749", "C840083671", "C38997010", "M1234567890"],
            "oldbalanceDest": [0.0, 0.0, 41554.0, 50585.53, 0.0],
            "newbalanceDest": [0.0, 21182.0, 0.0, 102676.81, 0.0],
            "isFraud": [0, 1, 1, 0, 0],
            "isFlaggedFraud": [0, 0, 0, 0, 0],
        }
        df = pd.DataFrame(data)
        data_manager._data = df
        data_manager._loaded = True

    def test_fraud_summary(self) -> None:
        """
        Teste le résumé des fraudes.
        """
        summary = FraudDetectionService.get_fraud_summary()
        self.assertEqual(summary.total_frauds, 2)
        self.assertGreaterEqual(summary.precision, 0.0)
        self.assertLessEqual(summary.precision, 1.0)
        self.assertGreaterEqual(summary.recall, 0.0)
        self.assertLessEqual(summary.recall, 1.0)

    def test_fraud_by_type(self) -> None:
        """
        Teste les statistiques de fraude par type.
        """
        fraud_stats = FraudDetectionService.get_fraud_by_type()
        self.assertEqual(len(fraud_stats), 5)

        # Vérifier que chaque type a des statistiques valides
        for stat in fraud_stats:
            self.assertGreaterEqual(stat.fraud_rate, 0.0)
            self.assertLessEqual(stat.fraud_rate, 1.0)

    def test_fraud_prediction_high_risk(self) -> None:
        """
        Teste la prédiction de fraude pour une transaction à haut risque.
        """
        request = FraudPredictionRequest(
            type="CASH_OUT",
            amount=500000.0,
            oldbalanceOrg=500000.0,
            newbalanceOrig=0.0,
            oldbalanceDest=0.0,
            newbalanceDest=0.0,
        )
        prediction = FraudDetectionService.predict_fraud(request)
        self.assertTrue(prediction.isFraud)
        self.assertEqual(prediction.risk_level, "high")

    def test_fraud_prediction_low_risk(self) -> None:
        """
        Teste la prédiction de fraude pour une transaction à faible risque.
        """
        request = FraudPredictionRequest(
            type="PAYMENT",
            amount=50.0,
            oldbalanceOrg=1000.0,
            newbalanceOrig=950.0,
            oldbalanceDest=500.0,
            newbalanceDest=550.0,
        )
        prediction = FraudDetectionService.predict_fraud(request)
        self.assertEqual(prediction.risk_level, "low")

    def test_fraud_prediction_edge_cases(self) -> None:
        """
        Teste les cas limites de prédiction de fraude.
        """
        # Transaction de type TRANSFER avec montant élevé
        request = FraudPredictionRequest(
            type="TRANSFER",
            amount=300000.0,
            oldbalanceOrg=300000.0,
            newbalanceOrig=0.0,
        )
        prediction = FraudDetectionService.predict_fraud(request)
        self.assertIsNotNone(prediction.probability)
        self.assertIn(prediction.risk_level, ["low", "medium", "high"])


if __name__ == "__main__":
    unittest.main()
